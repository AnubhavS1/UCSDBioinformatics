# returns a string from dna that is most probable based on the profile
def ProfileMostProbable(dna, k, matrix):
    k = int(k)
    best_prob = -1
    s = None
    for i in range(len(dna) - k + 1):
        pr = prob(dna[i:i + k], matrix)
        if pr > best_prob:
            best_prob = pr
            s = dna[i:i + k]
    return s


# calculate probability of a text being chosen based on the profile
def prob(text, pr):
    p = 1
    for i in range(len(text)):
        p *= pr[text[i]][i]
    return p


# generates a count matrix of nucleotides based on a motif array
def count(motifs):
    counts = {}
    t = len(motifs)
    k = len(motifs[0])
    # initialize counts dict
    for nuc in "ACGT":
        counts[nuc] = []
        for i in range(k):
            counts[nuc].append(1)
    # fill counts dict
    for i in range(t):
        for j in range(k):
            nuc = motifs[i][j]
            counts[nuc][j] += 1
    return counts


# creates a probability profile based on the count matrix generated by motif array
def profile(motifs):
    p = {}
    counts = count(motifs)
    # divide values in counts to get values for profiles
    for nuc in counts.keys():
        p[nuc] = [x / float(len(motifs) + 4) for x in counts[nuc]]
    return p


# finds a consensus string based on a collection of motifs
def consensus(m):
    con_str = ""
    k = len(m[0])
    counts = count(m)
    for i in range(k):
        freq = ""
        c = 0
        for nucleotide in "ACGT":
            if counts[nucleotide][i] > c:
                c = counts[nucleotide][i]
                freq = nucleotide
        con_str += freq
    return con_str


# determines how different a collection of motifs is from the consensus string
def score(motifs):
    con = consensus(motifs)
    k = len(motifs[0])
    t = len(motifs)
    score = 0
    for i in range(k):
        for j in range(t):
            if motifs[j][i] != con[i]:
                score += 1
    return score
